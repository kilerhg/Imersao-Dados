# -*- coding: utf-8 -*-
"""pesquisas_ibge

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qqyrlFWfANB5_FDcwp1r-FNQGBKzbsM4

## Historia

Tema: Diferenças de renda na grande são paulo

Importar dados SP

Separar dados da metropole

Grafico comparando municipios por renda & nota total

grafico scatter demonstrando desigualdade com dados totais

grafico de barras comparando renda media por municipio

Separar pessoas que de enquadram no caso de não poderem refazer a prova porém casos socio/economicos a impediram como:
não ter carro faltarem em 1 dos dias e ter renda menor que a média,
 
gerar as notas faltantes com machine learning, sendo o valor das notas a geradas subraida pelo desvio padrão 

Separar Graficos

Escrever Conclusão utilizando graficos como base

Ver live sobre Story Telling

ir comentando o codigo conforme construo

Extra: Escrever historia estilo RPG sendo a conclusão o FINAL BOSS

## Importando
"""

pip install geopandas

import json
import numpy as np
import sys
np.random.seed(0) # set a seed to enable reproducable results
import pandas as pd
import geopandas as gpd
import random
from shapely.geometry import Point, Polygon
import matplotlib.pyplot as plt
import seaborn as sns



"""## Base dados amostra"""

fonte = "https://github.com/alura-cursos/imersao-dados-2-2020/blob/master/MICRODADOS_ENEM_2019_SAMPLE_43278.csv?raw=true"

dados_amostra = pd.read_csv(fonte)
dados_amostra.head()

dados_amostra.columns.values

# interesse = ['NU_INCRICAO','CO_MUNICIPIO_RESIDENCIA','NO_MUNICIPIO_RESIDENCIA','NU_IDADE','TP_SEXO','COR_RACA','IN_TREINEIRO']
notas = ['NU_NOTA_CN','NU_NOTA_CH','NU_NOTA_LC','NU_NOTA_MT','NU_NOTA_REDACAO']

dados_amostra['NOTA_TOTAL'] = dados_amostra[notas].sum(axis=1)
dados_amostra_sem_zero = dados_amostra.query('NOTA_TOTAL != 0')

sp = dados_amostra_sem_zero.query('SG_UF_RESIDENCIA == "SP"')

dados_amostra['NOTA_TOTAL'] = dados_amostra[notas].sum(axis=1)
dados_amostra_sem_zero = dados_amostra.query('NOTA_TOTAL != 0')

sp = dados_amostra_sem_zero.query('SG_UF_RESIDENCIA == "SP"')

# interesse = ['NU_INCRICAO','CO_MUNICIPIO_RESIDENCIA','NO_MUNICIPIO_RESIDENCIA','NU_IDADE','TP_SEXO','COR_RACA','IN_TREINEIRO']
notas = ['NU_NOTA_CN','NU_NOTA_CH','NU_NOTA_LC','NU_NOTA_MT','NU_NOTA_REDACAO']

sp['NOTA_TOTAL'] = sp[notas].sum(axis=1)

todos_municipios_sp1 = sp['NO_MUNICIPIO_RESIDENCIA'].unique()
lista_municipios1 = ['Novo Horizonte', 'Mairinque', 'São Paulo', 'Bananal',
       'Itaquaquecetuba', 'Porto Ferreira', 'Tarumã', 'Guarulhos',
       'Arujá', 'Palmares Paulista', 'Campinas', 'Osasco',]
lista_municipios = ['São Paulo',
'Guarulhos',
'São Bernardo do Campo',
'Santo André',
'Osasco',
'Mauá',
'Mogi das Cruzes',
'Diadema',
'Carapicuíba',
'Itaquaquecetuba',
'Suzano',
'Taboão da Serra',
'Barueri',
'Embu das Artes',
'Cotia',
'Itapevi',
'Ferraz de Vasconcelos',
'Francisco Morato',
'Itapecerica da Serra',
'São Caetano do Sul',
'Franco da Rocha',
'Santana de Parnaíba',
'Jandira',
'Ribeirão Pires',
'Poá',
'Caieiras',
'Mairiporã',
'Arujá',
'Cajamar',
'Embu-Guaçu',
'Santa Isabel',
'Vargem Grande Paulista',
'Rio Grande da Serra',
'Biritiba Mirim',
'Juquitiba',
'Guararema',
'Pirapora do Bom Jesus',
'Salesópolis',
'São Lourenço da Serra']

sp.query(f'NO_MUNICIPIO_RESIDENCIA in {lista_municipios}')

dicionario = {}
lista_simples = []
for i in lista_municipios:
  var_temp = sp.query(f'NO_MUNICIPIO_RESIDENCIA == "{i}"')
  lista_simples.append(var_temp['NOTA_TOTAL'].mean())

dicionario = {}
for posi, i in enumerate(lista_municipios):
  var_temp = sp.query(f'NO_MUNICIPIO_RESIDENCIA == "{i}"')
  sujo = var_temp['NOTA_TOTAL'].mean()
  dicionario[i] = f'{sujo:.5f}'

a,b = dicionario.values(), dicionario.keys()

teste = pd.DataFrame({})
teste['Nome'] = b
teste['Nota'] = a

#teste.sort_values('Nota',ascending=False)
teste = teste.sort_values('Nome',ascending=True)

valores_media = teste['Nota']

temp01 = sp['Q006']

valores = ['B', 'A', 'J', 'E', 'C', 'M', 'D', 'I', 'N', 'F', 'H', 'O', 'Q',
       'G', 'K', 'P', 'L']
valores.sort()

renda_baixa = valores[:6]
renda_media = valores[6:12]
renda_alta = valores[12:]

dados_metropole = sp.query(f'NO_MUNICIPIO_RESIDENCIA in {lista_municipios_metropolitana}')

sp_baixa = dados_metropole.query(f'Q006 in {renda_baixa}')

sp_media = dados_metropole.query(f'Q006 in {renda_media}')

sp_alta = dados_metropole.query(f'Q006 in {renda_alta}')

plt.figure(figsize=(15,12))
plt.title('Comparação entre Renda e Nota Total Enem')
sns.histplot(data=sp_baixa,x='NOTA_TOTAL',kde=True,color='blue',alpha=.5,stat='density')
sns.histplot(data=sp_media,x='NOTA_TOTAL',kde=True,color='green',alpha=.5,stat='density')
sns.histplot(data=sp_alta,x='NOTA_TOTAL',kde=True,color='red',alpha=.5,stat='density')

plt.figure(figsize=(15,12))
plt.grid(b)
plt.title('Comparação entre Renda e Nota Total Enem')
sns.histplot(data=sp_baixa,x='NOTA_TOTAL',kde=True,color='blue',alpha=0,stat='density',element="poly")
sns.histplot(data=sp_media,x='NOTA_TOTAL',kde=True,color='green',alpha=0,stat='density',element="poly")
grafico_diferenca = sns.histplot(data=sp_alta,x='NOTA_TOTAL',kde=True,color='red',alpha=0,stat='density',element="poly")
grafico_diferenca.set_xlabel('Nota Total')
grafico_diferenca.set_ylabel('Quantidade')
grafico_diferenca.legend(labels=('Baixa','Média','Alta'),title='Classe')

copia_sp = dados_metropole[:]

renda_baixa

copia_sp['Q006'] = copia_sp['Q006'].replace(renda_baixa,'Renda Baixa')
copia_sp['Q006'] = copia_sp['Q006'].replace(renda_media,'Renda Média')
copia_sp['Q006'] = copia_sp['Q006'].replace(renda_alta,'Renda Alta')

teste06 = copia_sp.query('Q006 == "Renda Alta"')

len(teste06)

plt.figure(figsize=(20,17))
plt.title('Grafico ENEM 2019 Região Metropolitana, comparando A Nota de Ciências Humanas por Linguagem e Códigos pela Renda')
grafico_scatter = sns.scatterplot(data=copia_sp,x='NU_NOTA_LC',y='NU_NOTA_CH',hue='Q006')
grafico_scatter.legend(labels=('','Média','Baixa','Alta'),title='Renda')
grafico_scatter.set_xlabel('Nota Linguagem e Códigos')
grafico_scatter.set_ylabel('Nota Ciências Humanas')
plt.ylim(300,1050)
plt.xlim(300,1050)

"""## IBGE

Fonte IBGE: https://www.ibge.gov.br/geociencias/organizacao-do-territorio/estrutura-territorial/15774-malhas.html?edicao=15874&t=downloads
"""

pip install geopandas

import json
import numpy as np
import sys
np.random.seed(0) # defina uma seed para ter resultados reproduzidos
import pandas as pd
import geopandas as gpd
import random
from shapely.geometry import Point, Polygon
import matplotlib.pyplot as plt
import seaborn as sns

sp = gpd.read_file('/content/arquivos/SP_UF_2019.shp')
mesorregioes = gpd.read_file('/content/arquivos/SP_Mesorregioes_2019.shp')
microrregioes = gpd.read_file('/content/arquivos/SP_Microrregioes_2019.shp')
municipios = gpd.read_file('/content/arquivos/SP_Municipios_2019.shp')
imediatas = gpd.read_file('/content/arquivos/SP_RG_Imediatas_2019.shp')
intermediarias = gpd.read_file('/content/arquivos/SP_RG_Intermediarias_2019.shp')



municipios.plot(figsize=(14,14))

osasco = municipios.query("NM_MUN == 'Osasco'")
osasco.plot()

municipios

lista_municipios_metropolitana = ['São Paulo',
'Guarulhos',
'São Bernardo do Campo',
'Santo André',
'Osasco',
'Mauá',
'Mogi das Cruzes',
'Diadema',
'Carapicuíba',
'Itaquaquecetuba',
'Suzano',
'Taboão da Serra',
'Barueri',
'Embu das Artes',
'Cotia',
'Itapevi',
'Ferraz de Vasconcelos',
'Francisco Morato',
'Itapecerica da Serra',
'São Caetano do Sul',
'Franco da Rocha',
'Santana de Parnaíba',
'Jandira',
'Ribeirão Pires',
'Poá',
'Caieiras',
'Mairiporã',
'Arujá',
'Cajamar',
'Embu-Guaçu',
'Santa Isabel',
'Vargem Grande Paulista',
'Rio Grande da Serra',
'Biritiba Mirim',
'Juquitiba',
'Guararema',
'Pirapora do Bom Jesus',
'Salesópolis',
'São Lourenço da Serra']

lista_municipios_metropolitana.sort()

number_of_colors = len(lista_municipios_metropolitana)

color = ["#"+''.join([random.choice('0123456789ABCDEF') for j in range(6)])
             for i in range(number_of_colors)]

dicionario_cores = {}
for posi, i in enumerate(lista_municipios_metropolitana):
  dicionario_cores[i] = color[posi]

dicionario_cores

regiao_metropolitana = municipios.query(f"NM_MUN in {lista_municipios_metropolitana}")

regiao_metropolitana['cores'] = dicionario_cores

regiao_metropolitana['cores']

regiao_metropolitana

teste['Nota'].values

regiao_metropolitana['media'] = teste['Nota'].values

valor_nota = teste['Nota'].values

lista_percentual_notas = []
for i in valor_nota:
  lista_percentual_notas.append(eval(i)/4000)

lista_percentual_notas

regiao_metropolitana['percentual'] = lista_percentual_notas

regiao_metropolitana

grafico = regiao_metropolitana.plot(figsize=(25,20),column=regiao_metropolitana['percentual'],legend=True,legend_kwds={'label': "Media De Nota Por Cidade",'orientation': "horizontal"})
#grafico.legend(labels=[lista_municipios_metropolitana])

grafico = regiao_metropolitana.plot(figsize=(25,20),column=regiao_metropolitana['cores'],legend=True)
#grafico.legend(labels=[lista_municipios_metropolitana])

fig, ax = plt.subplots(1, 1)
regiao_metropolitana.plot(figsize=(10,10),column=regiao_metropolitana['percentual'],legend=True)
#grafico.legend(labels=[lista_municipios_metropolitana])

pip install contextily

import contextily as ctx

teste01 = regiao_metropolitana.plot(figsize=(25,20),column=regiao_metropolitana['cores'])



regiao_metropolitana.head()

grafico_sp = regiao_metropolitana

grafico = regiao_metropolitana.plot(figsize=(25,20),column=regiao_metropolitana['percentual'],legend=True,legend_kwds={'label': "Media De Nota Por Cidade",'orientation': "horizontal"})

fig = plt.figure(1, figsize=(50,25)) 
ax = fig.add_subplot()
grafico_sp.apply(lambda x: ax.annotate(s=x.NM_MUN, xy=x.geometry.centroid.coords[0], ha='center', fontsize=14),axis=1);
grafico_sp.boundary.plot(ax=ax, color='Black', linewidth=.4)
grafico_sp.plot(ax=ax, cmap='Dark2', figsize=(12, 12),column=regiao_metropolitana['percentual'],legend=True)
#west.plot(figsize=(25,20),column=regiao_metropolitana['percentual'],legend=True,legend_kwds={'label': "Media De Nota Por Cidade",'orientation': "horizontal"})
#ax.text(-0.05, 0.5, 'L', transform=ax.transAxes,
#        fontsize=20, color='gray', alpha=0.5,
#       ha='center', va='center', rotation='90')

fig = plt.figure(1, figsize=(50,25)) 
ax = fig.add_subplot()
grafico_sp.apply(lambda x: ax.annotate(s=x.NM_MUN, xy=x.geometry.centroid.coords[0], ha='center', fontsize=14),axis=1);
grafico_sp.boundary.plot(ax=ax, color='Black', linewidth=.4)
grafico_sp.plot(ax=ax ,figsize=(12, 12),column=regiao_metropolitana['percentual'],legend=True)
#ax.text(-0.05, 0.5, 'L', transform=ax.transAxes,
#        fontsize=20, color='gray', alpha=0.5,
#       ha='center', va='center', rotation='90')

regiao_metropolitana.head()

dados_osasco = dados_amostra_sem_zero.query('NO_MUNICIPIO_RESIDENCIA == "São Paulo"')

dados_osasco.head()

categorias_sociais = ['B', 'A', 'J', 'E', 'C', 'M', 'D', 'I', 'N', 'F', 'H', 'O', 'Q',
       'G', 'K', 'P', 'L']
categorias_sociais.sort()

classe_social_numerado = {}
for posi, i in enumerate(categorias_sociais):
  sujo = (posi+1)/17
  classe_social_numerado[i] = f'{sujo:.2f}'

dados_metropole = sp.query(f'NO_MUNICIPIO_RESIDENCIA in {lista_municipios_metropolitana}')

dados_metropole

teste_dados_metropole = dados_metropole[:]

dicionario_teste = {}
lista_teste = []
for pose, e in enumerate(categorias_sociais):
  for posi, i in enumerate(lista_municipios_metropolitana):
    pesquisa_cidade = teste_dados_metropole.query(f'NO_MUNICIPIO_RESIDENCIA == "{i}"')
    if len(pesquisa_cidade) > 0:
      pesquisa_social = pesquisa_cidade.query(f'Q006 == "{e}"')
      soma_pesquisa = len(pesquisa_social)
      lista_teste.append(soma_pesquisa)
  dicionario_teste[i] = lista_teste[:]
  lista_teste.clear

dicionario_teste = {}
lista_teste = []
for posi, i in enumerate(lista_municipios_metropolitana):
  pesquisa_cidade = teste_dados_metropole.query(f'NO_MUNICIPIO_RESIDENCIA == "{i}"')
  for pose, e in enumerate(categorias_sociais):
    if len(pesquisa_cidade) > 0:
      pesquisa_social = pesquisa_cidade.query(f'Q006 == "{e}"')
      soma_pesquisa = len(pesquisa_social)
      lista_teste.append(soma_pesquisa)
  dicionario_teste[i] = lista_teste[:]
  lista_teste.clear()

dicionario_teste

teste07 = teste_dados_metropole.query('Q006 == "C"')

sum(lista_teste)

classe_social_numerado

"""## Conclusão

### Texto

Segundo as Informações levantadas e os mapas de calor refente a grande São Paulo com os dados aplicados vemos que existem alguns municipios que concentram as notas, porem elas estão bem espalhadas ao todo, o que se contradiz com o grafico sccater, onde vemos claramente uma concentração de notas na Renda Media / Alta, porem uma grande concentração de pessoas de baixa renda nas notas mais baixas, o que colocado lado a lado o scatter e o mapa de são paulo podemos chegar a conclusão que as notas medias são sempre com um desvio padrão parecido pois em todas as cidades existem mais pessoas pobres, o que segundo o scatter tendem a ter uma nota menor equilibrando as médias.

### Gráficos Citados
"""

fig = plt.figure(1, figsize=(50,25)) 
ax = fig.add_subplot()
grafico_sp.apply(lambda x: ax.annotate(s=x.NM_MUN, xy=x.geometry.centroid.coords[0], ha='center', fontsize=14),axis=1);
grafico_sp.boundary.plot(ax=ax, color='Black', linewidth=.4)
grafico_sp.plot(ax=ax ,figsize=(12, 12),column=regiao_metropolitana['percentual'],legend=True)
#ax.text(-0.05, 0.5, 'L', transform=ax.transAxes,
#        fontsize=20, color='gray', alpha=0.5,
#       ha='center', va='center', rotation='90')

plt.figure(figsize=(20,17))
plt.title('Grafico ENEM 2019 Região Metropolitana, comparando A Nota de Ciências Humanas por Linguagem e Códigos pela Renda')
grafico_scatter = sns.scatterplot(data=copia_sp,x='NU_NOTA_LC',y='NU_NOTA_CH',hue='Q006')
grafico_scatter.legend(labels=('','Média','Baixa','Alta'),title='Renda')
grafico_scatter.set_xlabel('Nota Linguagem e Códigos')
grafico_scatter.set_ylabel('Nota Ciências Humanas')
plt.ylim(300,1050)
plt.xlim(300,1050)

plt.figure(figsize=(15,12))
plt.grid(b)
plt.title('Comparação entre Renda e Nota Total Enem')
sns.histplot(data=sp_baixa,x='NOTA_TOTAL',kde=True,color='blue',alpha=0,stat='density',element="poly")
sns.histplot(data=sp_media,x='NOTA_TOTAL',kde=True,color='green',alpha=0,stat='density',element="poly")
grafico_diferenca = sns.histplot(data=sp_alta,x='NOTA_TOTAL',kde=True,color='red',alpha=0,stat='density',element="poly")
grafico_diferenca.set_xlabel('Nota Total')
grafico_diferenca.set_ylabel('Quantidade')
grafico_diferenca.legend(labels=('Baixa','Média','Alta'),title='Classe')